# Companion App Service Architecture Guide
This is a quick tour of the internal architecture for the Companion App Service.
For information on the REST API, see [API](/API.md). For information on how
the service integrates with the rest of the OS, see [OS Integration](/OSIntegration.md).

# Principles

## Stateless
Asides from caches and request-specific local state kept during the handling
of a request, the Service does not keep any state, neither in memory nor
on disk. It should be possible restart the servie at any time between
the handling of requests without any apparent disruption to a user of the
Companion App. Such a principle allows the Service to work with
systemd [Socket Activation](/OSIntegration.md#Socket-Activation), such that
the Service process will automatically terminate after five minutes of
inactivity (but is kept in memory whilst it is still serving clients).

## Functional core, Imperative shell
Where possible, the service is composed of pure functions (which themselves
are not made up of functional expressions, but do not have side effects
other than updating caches). In general, functional constructs inside of
functions are preferred, but not required as long as the result is
that the function does not have externally observable side effects.
Objects with persistent mutable state should be avoided unless
it would be extremely awkward to use a comparable functional construct.
See the talk [Boundaries](https://www.destroyallsoftware.com/talks/boundaries)
by Gary Bernhardt for inspiration.

Readers of the code will often observe the following patterns:

### Closures over objects
Where some state needs to be store before a function is called later
(usually as part of an asynchonous callback chain),
[Partial application](https://en.wikipedia.org/wiki/Partial_application)
is used instead of an object defintion. For instance:

    def apply_route_version(handler, route_version):
        '''Partially apply route_version to the end of handler.'''
        def wrapper(*args, **kwargs):
            '''Call route with route_version applied to the end.'''
            all_args = itertools.chain(args, [route_version])
            return handler(*all_args, **kwargs)

        return wrapper

The function `apply_route_version` returns another function with
`route_version` partially applied - it is saved as part of
the function's closure, in the same way that it might be
saved as part of an object's properties. See
[Closures And Objects Are Equivalent](http://wiki.c2.com/?ClosuresAndObjectsAreEquivalent=).

### Functional collection operators
Where a transformation, filter or summary needs to be applied
to a list or a dictionary, prefer using a
[comprehension](http://python-3-patterns-idioms-test.readthedocs.io/en/latest/Comprehensions.html)
to mutating a local list or dictonary variable in a loop. If you need to implement
some more complex logic for generating an initial collection, consider using
[iterables](#iterables-and-lazy-evaluation)

### Iteratables and lazy evaluation
Where a function needs to generate a collection where the size is not known in
advance because the list is generated by an unknown number of IO operations or
the result of some complex algorithm, consider using a generator, for instance:

    def link_tables_from_shards(shards):
        '''Look up all the link tables in the shards and yield them.'''
        for shard in shards:
            link_table_record = shard.find_record_by_hex_name(_LINK_TABLE_ID)

            if link_table_record is not None:
                yield link_table_record.data.load_as_dictionary()

Generators can be combined with comprehensions for further filtering
or transformation. They are also run lazily, meaning that the function
yielding each entry is run once per iteration of the iterable. This can
avoid wasted cycles if the calling code does not need to iterate
through the entire generator.

Consider also making use of the [itertools](https://docs.python.org/3/library/itertools.html)
library. The Service makes heavy use of
[`itertools.chain.from_iterable`](https://docs.python.org/3/library/itertools.html#itertools.chain.from_iterable)
in order to efficiently concatenate sequences together without the allocation overhead
of pasting them all together in memory.

## Asynchronous
Where possible, always prefer asynchronous IO to synchronous IO. Such a design
is inspired by the [non-blocking-by-default](https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/)
design in Node. The service is supposed to handle multiple concurrent
requests at once (for instance, a single Mission One computer serving an
entire classroom of Android devices). This can be done so long as a single
request doesn't get stuck waiting for all the others to complete.

Unfortunately, Python itself is single-threaded by nature due to the
[Global Interpreter Lock](https://en.wikipedia.org/wiki/Global_interpreter_lock).
However, the GIL does not preclude running IO in a separate non-interpreter
thread and reporting the results back to the
[main loop](https://developer.gnome.org/glib/stable/glib-The-Main-Event-Loop.html).
Indeed, this is how [GTask](https://developer.gnome.org/gio/stable/GTask.html)
works.


## Implementing async operations
Typically, if you need to implement some async operation that is not already in
Gio (or would require a complex series of callbacks to implement from within
the Python code), you can implement a new set of async functions in
`src/eos-companion-app-integration-helper.c`. They will be added as methods
in the `EosCompanionAppService` namespace through the use of
[GObject-Introspection](https://wiki.gnome.org/Projects/GObjectIntrospection).
Usually you would implement async operations through the use of GTask. GTask
provides a way to spawn another thread where you can do synchronous IO and then
return the result or an error of those operations back to the main loop by using
`g_task_propagate_pointer` or `g_task_return_error`. For instance:

    static void
    load_application_colors_thread (GTask        *task,
                                    gpointer      source,
                                    gpointer      task_data,
                                    GCancellable *cancellable)
    {
      g_autoptr(GError) local_error = NULL;
      g_auto(GStrv) colors = load_colors_for_app_id ((const gchar *) task_data,
                                                     &local_error);

      if (colors == NULL)
        {
          g_task_return_error (task, g_steal_pointer (&local_error));
          return;
        }

      g_task_return_pointer (task,
                             g_steal_pointer (&colors),
                             (GDestroyNotify) g_strfreev);
    }

    void
    eos_companion_app_service_load_application_colors (const gchar         *app_id,
                                                       GCancellable        *cancellable,
                                                       GAsyncReadyCallback  callback,
                                                       gpointer             user_data)
    {
      g_autoptr(GTask) task = g_task_new (NULL, cancellable, callback, user_data);

      g_task_set_return_on_cancel (task, TRUE);
      g_task_set_task_data (task, g_strdup (app_id), g_free);
      g_task_run_in_thread (task, load_application_colors_thread);
    }

    GStrv
    eos_companion_app_service_finish_load_application_colors (GAsyncResult  *result,
                                                              GError       **error)
    {
      g_return_val_if_fail (g_task_is_valid (result, NULL), NULL);

      return g_task_propagate_pointer (G_TASK (result), error);
    }


The functions `eos_companion_app_service_load_application_colors` and
`eos_companion_app_service_finish_load_application_colors` are exposed
to Python through `EosCompanionAppService`. You would then use the async
function by passing its parameters and a callback function from python:

    def get_first_color_async(app_id, cancellable, callback):
        def on_got_colors_result(_, result):
            '''Called when we get the GAsyncResult.'''
            try:
                colors = EosCompanionAppService.finish_load_application_colors(result)
            except GLib.Error as error:
                # Handle error

            callback(colors[0])

        EosCompanionAppService.load_application_colors(app_id,
                                                       cancellable,
                                                       on_got_colors_result)


One thing to note is that async functions typically take both a callback
and a cancellable parameter. As a rule of thumb, all async functions
receive a cancellable and should pass that cancellable to any other
functons that it calls which also take a cancellable, even if the
cancellable is NULL. This allows for requests to be terminated early
if the client closes the connection before it receives the result
(for instance, the user of the app navigated to some other view before
the current view finished loading).

Since the default implementation for GTask is to use threads, you
should take the same precautions that you would usually take when
doing multithreaded programming. Do not share mutable data between
threads without an appropriate locking mechanism and prefer to avoid
sharing data between threads at all, instead relying on message
passing with only one thread owning data at a time. Using
`g_task_propagate_pointer` is a good way to stick to this guideline.

## Running multiple async tasks concurrently
Sometimes you might want to run an async task for each member of
a collection. Not only is doing so in serial extremely awkward to
implement, it is also inefficient because the problem is probably
[embarassingly parallel](https://en.wikipedia.org/wiki/Embarrassingly_parallel).

The `all_asynchronous_function_calls_closure` function
from `eoscompanion.functional` comes in handy here. It is very similar to
[`Q.allSettled`](http://documentup.com/kriskowal/q/#combination) from
the `Q` JavaScript library. The function takes an iterable of function
objects each taking a single argument, a callback, which the function
should call once its asynchronous operation completes. The second
argument to `all_asynchronous_function_calls_closure` is a callback
that receives an array of `(error, result)` tuples. The callback should
loop over all the tuples, handle the errors, then do something with the
results.

## Isolation and library independence
The Service itself is packaged as a Flatpak and runs
on its own private session bus and as its own user. See
[OS Integration](/docs/OSIntegration.md) for more information.

The Service also does not have a library dependency on any
single version of the
[Endless Knowledge Content Framework](https://github.com/endlessm/eos-knowledge-lib).
Instead, it depends on a set of session-level services
called [`EknServices`](https://github.com/endlessm/eos-knowledge-services),
generally speaking one for each SDK major version, and a
stable interface exported by all of them called
[`MetadataProvider`](https://github.com/endlessm/eos-knowledge-services/blob/master/docs/MetadataProvider.md).
When providing content for an app, the Service determines
which SDK version it was built against and makes a
call to the corresponding `EknServices` version to
make queries against its database. The actual content
is read by linking to a library called
[`eos-shard`](https://github.com/endlessm/eos-shard), which
exports a stable ABI between SDK versions and is backward
compatible with all published shard versions.

## Backward compatibility with older Companion App versions
No matter how new the Service version is, it should
generally speaking be possible to use older app versions
with it. If new API is to be exposed, then a
[versioning mechanism](docs/API.md#concurrent-service-api-versioning)
is provided, usually by bumping the supported server
version number and providing a new route prefix (eg,
/v1 -> /v2). This is acheived with the
`apply_version_to_all_routes` helper in `eoscompanion.middlewares`.

# Tour
The source code of the project is divided into main parts.

- `/src`: Contains all the C source code and routines. These
          are mostly handwritten async operations which run
          concurrently to the Python thread in order to do
          IO like loading content from
          [shard files](https://github.com/endlessm/eos-shard)
          or reading Flatpak metadata. There isn't much
          meaning to the separation of files in this directory -
          there are a couple of utility classes like
          `EosCompanionAppServiceAppInfo` but most of the async
          operations are in `companion-app-integration-helper.c`.
- `/eoscompanion`: Contains all the Python source code and the
                   entry point for the application. This is
                   where we set up the
                   [libsoup](https://wiki.gnome.org/Projects/libsoup)
                   server and define all the route callbacks.

## The `eoscompanion` module
The main entry point for the application is in `eoscompanon.main`. This
creates a `GApplication` subclass which manages the lifecycle of the
process. That in turn uses `eoscompanion.service` to create
a `CompanionAppService` object which manages the server's lifecycle
as well as any mutable caches.

The `Soup.Server` (HTTP Server) instance is created the
`CompanionAppService`' constructor, using `create_companion_app_webserver`
from `eoscompanion.server`. That method will create all the routes
(imported from `eoscompanion.v1_routes` and `eoscompanion.v2_routes`),
apply middlewares to them (imported from `eoscompanion.middlewares`)
and register them with the server. Once that is complete,
`CompanionAppService` calls
`eos_companion_app_service_soup_server_listen_on_sd_fd_or_port`, which
causes the server to start listening on a given TCP/IP port, or passes
it a file-descriptor given to the process by systemd if it was started
by socket activation.

Once that is done, clients can start making HTTP requests to the server
until it is shut down with `CompanionAppService.stop` or the
process exits (usually done implicitly by `CompanionAppApplication`
in its quit lifecycle step).

### Standard resposnes
Since libsoup only supports binary responses through
[`soup_message_set_response`](https://developer.gnome.org/libsoup/stable/SoupMessage.html#soup-message-set-response),
(which is not properly introspectable anyway), the
`eoscompanion.responses` module provides a few helpers
to avoid all the code needed to convert higher-level
responses such as JSON into binary. For instance:

 - `error_response`: Given a `GError`, return an error response
                     according to the
                     [API Documentation](/API.md). The error code
                     from the `GError` will automatically be
                     translated into a corresponding error in
                     the `EosCompanionAppService.Error` domain.
 - `not_found_response`: Return a 404 and corresponding error response.
 - `json_response`: Serialize a Python dictionary into JSON and return
                    it as text, with content-type set to `application/json`.
 - `png_response`: Send PNG encoded image bytes as binary, with
                   content-type set to `image/png`.
 - `jpeg_response`: Send JPEG encoded bytes as binary, with content-type
                    set to `image/jpeg`.
 - `html_response`: Send a string containing HTML as text, with content-type
                    set to `text/html`.
 - `custom_response`: Send bytes with a specified content-type.

The `respond_if_error_set` helper can be used to simplify
error handling code by immediately responding with an error
if the passed in error is non-NULL, returning `True` if
a response was set, `False` otherwise.

### Middlewares
Following the design of [Express](https://expressjs.com/en/guide/using-middleware.html),
middlewares are used to implement shared logic before route
handlers are even run.  Even though there is no first-class
support for middlewares in libsoup, the Companion App Service
uses function composition to implement middleware functionality.

To avoid lots of nested function applications, the `compose_middlewares`
function can be used to automatically provide a partially applied
function that runs all the specified middlewares in order. Middlewares
can also be applied as function
[decorators](http://book.pythontips.com/en/latest/decorators.html)
where they don't have any dependency on data constructed in
`CompanionAppService`. For instance, the `record_metric` decorator
only has a dependency on the
[`EosMetrics.EventRecorder`](https://github.com/endlessm/eos-metrics/blob/master/eosmetrics/emtr-event-recorder.h)
singleton, so it is used a decorator

Middlewares are used to provide all sorts of functionality, for
example:
 - Passing additional arguments to route handlers such
   as the connection to the content databases, or
   cancellable (`add_content_db_conn`,
   `cancellability middleware`).
 - Early error detection, such as missing required querystring
   parameters or trying to access an invalid route
   (`require_query_string_param`, `handle_404_middleware`).
 - Side effects, such as recording metrics (`record_metric`).

### Content Database Connection
Since the Service does not link to the Knowledge Framework
directly, it needs to maintain a connection to EknServices to
query content databases. This is done through the
'EknServicesContentDbConnection` in the `eoscompanion.eknservices_bridge`
module. That class follows the
[repository pattern](https://deviq.com/repository-pattern/) - it
provides a few high level methods to access relevant data as
a collection without exposing the details of maintaining
D-Bus connections and deserializing the data.

The `query` method uses the `MetadataProvider` API to find
content according to some constraints such as its title,
tags and content-type. Callers pass an `ApplicationListing`
object (usually created from `application_listing_for_app_info`
in `eoscompanion.applications_query`) so that the method can
work out which EknServices version to use (see
https://github.com/endlessm/eos-knowledge-services-multiplexer/blob/master/multi-services/eks-multi-search-provider-dispatcher.c
for the authoritative reference on how SDK versions
map to difference EknServices versions).

The `feed` method just uses [libcontentfeed](https://github.com/endlessm/libcontentfeed)
to return the same contents as the [Discovery Feed](https://github.com/endlessm/eos-discovery-feed).

### Content Rewriting and Rendering
The content (especially HTML content) read directly out of a shard often
isn't suitable for sending to the Companion App straight away. Amongst other
things, the links will be `ekn://`, `resource://`, or `license://` style links,
meaning that they won't resolve on the Companion App when clicked. In
addition, older content that does not use server templating will not have
any styles applied and will render in a mobile-unfriendly way.

To handle this problem, the Service has the concept of a 'Content Adjuster'
designed to handle content coming from various sources. The Content Adjuster
implements a `needs_adjustment` method to advise on whether the content
stream needs to be loaded into memory as bytes and a `render_async` method
to actually transform the read bytes into another byte sequence asynchronously,
suitable for consumption by the Companion App.

In general, adjusting content is an expensive operation, since it precludes
the ability to stream content directly from disk using Gio (see
[Content Streaming and Partial Content](#content-streaming-and-partial-content)
below). The entire byte sequence also needs to be loaded into memory all at
once as well.

To use a Content Adjuster, the caller should create the appropriate
Content Adjuster class, then pass the adjuster and the `Gio.InputStream` of
the content itself to `conditionally_wrap_stream`, defined in
`eoscompanion.content_streaming`. That method will asynchoronously determine
if adjustment needs to be applied and pass either the existing stream or
a new stream to the callback, along with the expected stream length.

### `EknContentAdjuster`
The `EknContentAdjuster` class (defined in `eoscompanion.ekn_content_adjuster`)
is used for routes that read HTML content from Endless Knowledge App shard files.

First, it applies some regular expressions to the content to replace all the
`ekn://`, `license://` and `resource://` links with relative paths to routes
defined by the Service which allow the device to load the relevant resource
correctly. For instance, `ekn://` URIs will be re-written as
`/vN/content_data` paths, with query-string parameter set such that the
underlying resource can be loaded.

Second, it uses
[`eos-knowledge-content-renderer`](https://github.com/endlessm/eos-knowledge-content-renderer)
to wrap the HTML content in another document that contains some additional
metadata about the content, that is used by some injected JavaScript code
to determine what links to enable. It also injects some `<script>` tags which
allow embedded information tables to be collapsed.

Finally, for content that requires it, `eos-knowledge-content-renderer` is
used to apply styling to content that does not have it, depending on its
source, using the `EosKnowledgeContentRenderer.render_legacy_content` method.

### `LicenseContentAdjuster`
This adjuster is used on license files served with `/vN/license`. The licenses
themselves are served from disk at the path specified by
`Endless.get_license_file`. The adjuster rewrites embedded CSS and image
paths to use `/vN/resource` with a URI-encoded parameter that allows
the relevant file to be resolved on disk.

### Content Streaming and Partial Content
Since large seekable files can be served by the Service to the Companion App,
it is important that Service supports the relevant HTTP streaming
protocols, such that the App can quickly seek through the content
and only downloads chunks that it requires.

This is achieved through the use of the "Content-Range" and "Partial-Content"
[specification](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206).
The linked document has more information, but in our implementation
we need to get an uncompressed stream to the file, work out how long that
stream is (ideally without loading it all into memory),
skip ahead N bytes in the stream depending on how far the client requested in
its `Range` request header, set the `Content-Range` header to the start
point and number of bytes, then use
[`Gio.OutputStream.splice_async`](https://developer.gnome.org/gio/stable/GOutputStream.html#g-output-stream-splice-async)
to lazily concatenate the skipped `Gio.InputStream` to the end of the
output stream writing to the network.

Content streaming is only supported on the /content_data route, but it
could be extended to other routes in future.

# Testing
Since this code has a high development velocity, we want to make sure
that we don't introduce any regressions during development. To that
extent, we utilize a high degree of black box testing, with a test suite
simulating an actual client interacting with the service backed by
fake apps.

The fake app files are defined in `test_data`. Each app has an
`overrides.scss` file, a `.desktop` file, an icon and a
[`GResource`](https://developer.gnome.org/gio/stable/GResource.html)
file, compiled with `generate_gresource_file.sh` in `test_data/scripts`,
see [here](/test_data/scripts/README.md) for more information.

When the `test.test_service` module is loaded, those fake apps are assembled
into a flatpak-like directory structure by `setup_fake_apps` in
`test.build_app` in a temporary directory, an the environment variable
`EOS_COMPANION_APP_FLATPAK_SYSTEM_DIR` is set to tell the Service
where to look for "flatpaks" at test time.

We have tests for all route versions, each defined in their own file. The
tests themselves are loaded into `test.test_service` such that the
module setup and teardown functions are only run once.

Each time a test is run, the first available user accessible TCP port is
found and a new Service from `eoscompanion.service` is created and run
on that port. The test typically makes an HTTP request similar to the
one made by the application and uses matchers from
[`testtools`](http://testtools.readthedocs.io/en/latest/api.html) to
validate the returned response within the main loop.

## Testing asynchronously with `testtools` and `unittest`
Python's `unittest` framework does not run tests asynchronously, which
presents a problem for testing the Service as everything in the service
runs asynchronously.

Helpers from `test.service_test_helpers` try to reduce the awkwardness
of this situation. The `@with_main_loop` decorator applied to every
test method will create a GLib Main Loop, add a single bootstrapping
source which runs the test method and then run the main loop, passing
a `quit` handle to the test as an argument. When the test has finished
running, it can call the `quit` handle to stop the main loop and pass the
test result back to the runner. If an exception was caught, that can be passed
as the `exception` keyword.

One remaining issue is how tests should deal with unexpected exceptions in
callbacks. If the `quit` handler is not called because an exception propagates
up to a call boundary in a callback from C, then the test will never complete
and hang. The `autoquit` helper can help to avoid this problem. It wraps
a callback in another function that catches exceptions and passes them
to the `quit` handler so that the test is marked as failed and the exception
is reported.

## Making requests and handling responses
Since libsoup only exposes an API that operates on bytes, there are some
helpers in the `test.service_test_helpers` library that make it easier
to interact with endpoints that expect a querystring and return
JSON.

The `json_http_request_with_uuid` function authenticates a fake UUID with
the service first, then makes a request to the given endpoint with
query-string parameters specified in a provided object. It also takes
a handler which can handle the returned byte data and headers.

The `handle_json` wrapper can wrap another function that expects a Python
object created from parsed JSON and acts as a "middleware", decoding the
bytestream response into text, then parsing the json and passing it to
the callback.

With the use of these helpers, a typical test thus might look as follows:

    @with_main_loop
    def test_list_applications_contains_video_app(self, quit_cb):
        '''/v1/list_applications should contain video app.'''
        def on_received_response(response):
            '''Called when we receive a response from the server.'''
            self.assertThat(
                [a for a in response['payload'] if a['applicationId'] == 'org.test.VideoApp'][0],
                ContainsDict({
                    'applicationId': Equals('org.test.VideoApp'),
                    'displayName': Equals('Video App'),
                    'shortDescription': Equals('A description about a Video App'),
                    'icon': matches_uri_query('/v1/application_icon', {
                        'iconName': MatchesSetwise(Equals('org.test.VideoApp')),
                        'deviceUUID': MatchesSetwise(Equals(FAKE_UUID))
                    }),
                    'language': Equals('en')
                })
            )
        self.service = CompanionAppService(Holdable(),
                                           self.port,
                                           FakeContentDbConnection(FAKE_SHARD_CONTENT))
        json_http_request_with_uuid(FAKE_UUID,
                                    local_endpoint(self.port,
                                                   'list_applications'),
                                    {},
                                    handle_json(autoquit(on_received_response,
                                                         quit_cb)))

## `FakeContentDbConnection`
Since we cannot spawn D-Bus services from the tests, nor should we access
applications installed on the system, the `FakeContentDbConnection` stands
in place of `EknServicesContentDbConnection` and implements the same API. It
is passed a dataset comprising the content and metadata for each of the
fake apps in a similar format to the `db.json` files used
by [`libingester`](https://github.com/endlessm/libingester). Queries are done
entirely against the fake content and metadata provided and the "shard" files
passed to the callback implement the Shard API but actually just read
fake data content from memory.
